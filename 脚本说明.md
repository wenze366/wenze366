**脚本说明**  000000

# 一、基础信息

### 1. 创建脚本环境；

```bash
mkdir -p /home/gbase/script/{conf,logs,bin,data}
```

| 英文名称 | 说明                     |
| -------- | ------------------------ |
| script   | 脚本文件夹（数据转储）； |
| conf     | 相关配置信息文件夹；     |
| logs     | 日志文件夹；             |
| bin      | 执行脚本文件夹；         |
| data     | 保存数据文件夹；         |

### 2. 数据库用户创建及权限；

```sql
# 创建 admin 用户，只拥有 select、insert目标表权限；
create user admin identified by 'admin';
grant select on hds.* to admin;
grant all on testdb.* to admin;
grant insert on hds.hx_bafm42_2024_bak_01 to admin;
grant insert on hds.hx_glsfmgdat_2024_bak_01 to admin;
grant insert on hds.edzf_nxy_srl_cbnkaccg_2024_bak_01 to admin;
grant insert on hds.cg_bb_dw_gl_balance_d_f_2024_bak_01 to admin;
grant insert on hds.edzf_nxy_srl_book_2024_bak_01 to admin;
grant insert on hds.hx_glsfmfdtl_2024_bak_01 to admin;
grant insert on hds.hx_join_flow_2024_bak_01 to admin;
grant insert on hds.hx_pfsftpjrn_2024_bak_01 to admin;
grant insert on hds.hx_glsftgent_2024_bak_01 to admin;
grant insert on hds.hx_pfsftcjrn_2024_bak_01 to admin;

# 查询admin用户权限
gbase> show grants for admin;
+--------------------------------------------------------------------------------------+
| Grants for admin@%                                                                   |
+--------------------------------------------------------------------------------------+
| GRANT USAGE ON *.*.* TO 'admin'@'%' IDENTIFIED BY PASSWORD '*4ACFE3202A5FF5CF467898FC58AAB1D615029441'                                            |
| GRANT SELECT ON "vc00001"."hds".* TO 'admin'@'%'                                     |
| GRANT ALL PRIVILEGES ON "vc00001"."testdb".* TO 'admin'@'%'                          |
| GRANT INSERT ON "vc00001"."hds"."edzf_nxy_srl_cbnkaccg_2024_bak_01" TO 'admin'@'%'   |
| GRANT INSERT ON "vc00001"."hds"."hx_bafm42_2024_bak_01" TO 'admin'@'%'               |
| GRANT INSERT ON "vc00001"."hds"."cg_bb_dw_gl_balance_d_f_2024_bak_01" TO 'admin'@'%' |
| GRANT INSERT ON "vc00001"."hds"."hx_pfsftcjrn_2024_bak_01" TO 'admin'@'%'            |
| GRANT INSERT ON "vc00001"."hds"."hx_pfsftpjrn_2024_bak_01" TO 'admin'@'%'            |
| GRANT INSERT ON "vc00001"."hds"."edzf_nxy_srl_book_2024_bak_01" TO 'admin'@'%'       |
| GRANT INSERT ON "vc00001"."hds"."hx_glsfmgdat_2024_bak_01" TO 'admin'@'%'            |
| GRANT INSERT ON "vc00001"."hds"."hx_glsfmfdtl_2024_bak_01" TO 'admin'@'%'            |
| GRANT INSERT ON "vc00001"."hds"."hx_join_flow_2024_bak_01" TO 'admin'@'%'            |
| GRANT INSERT ON "vc00001"."hds"."hx_glsftgent_2024_bak_01" TO 'admin'@'%'            |
+--------------------------------------------------------------------------------------+
13 rows in set (Elapsed: 00:00:00.00)
```

这些SQL语句是用于创建用户并授予权限的。解释每一条语句的作用：

 `create user admin identified by 'admin';`

- 创建一个名为 'admin' 的新用户，密码也设置为 'admin'。

`grant select on hds.* to admin;`

- 授予 admin 用户对 hds 数据库中所有表的 SELECT 权限。

`grant all on testdb.* to admin;`

- 授予 admin 用户对 testdb 数据库中所有对象的所有权限。

 `grant insert on hds.[table_name] to admin;`

   - 这些语句授予 admin 用户对 hds 数据库中特定表的 INSERT 权限。这些表包括：
     - hx_bafm42_2024_bak_01
     - hx_glsfmgdat_2024_bak_01
     - edzf_nxy_srl_cbnkaccg_2024_bak_01
     - cg_bb_dw_gl_balance_d_f_2024_bak_01
     - edzf_nxy_srl_book_2024_bak_01
     - hx_glsfmfdtl_2024_bak_01
     - hx_join_flow_2024_bak_01
     - hx_pfsftpjrn_2024_bak_01
     - hx_glsftgent_2024_bak_01
     - hx_pfsftcjrn_2024_bak_01

**这些权限设置允许 admin 用户：**

1. 查看 hds 数据库中的所有数据。
2. 对 testdb 数据库进行所有操作。
3. 向 hds 数据库中的特定表插入数据。

**安全建议：**

1. 在生产环境中，应使用更强的密码，而不是 'admin'。
2. 遵循最小权限原则，只授予必要的权限。
3. 定期审查用户权限，确保它们仍然适当。
4. 考虑使用角色来管理权限，特别是当有多个用户需要类似的权限集时。

### 3. 创建数据统计表；

```sql
#创建采集表
create database testdb;

use testdb;

create table testdb.source_table (
v_id int  COMMENT '序号',
v_tbname varchar(100)  COMMENT '表名',
v_date varchar(6)  COMMENT '转储年月',
v_count_valuse DECIMAL (15,0)  COMMENT '转储年月统计值',
v_crc32_valuse DECIMAL (30,0)  COMMENT '转储年月crc32校验值',
v_timestamp timestamp DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP  COMMENT '此列更新时间'
) COMMENT='原表信息统计' ;

create table testdb.target_table (
v_id int COMMENT '序号',
v_tbname varchar(100) COMMENT '表名',
v_date varchar(6) COMMENT '转储年月',
v_count_valuse DECIMAL (15,0) COMMENT '转储年月统计值',
v_crc32_valuse DECIMAL (30,0) COMMENT '转储年月crc32校验值',
v_exec varchar(6) COMMENT '转储年月执行时间',
v_timestamp timestamp DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '此列更新时间'
) COMMENT='目标表信息统计' ;
```

这些SQL语句用于创建数据库和表。详细解释每一部分：

#### 3.1. 创建数据库：

```sql
create database testdb;
```
这条语句创建了一个名为 `testdb` 的新数据库。

#### 3.2. 选择数据库：

```sql
use testdb;
```
这条语句将当前工作环境切换到 `testdb` 数据库。

#### 3.3. 创建 source_table：

```sql
create table testdb.source_table (
  v_id int COMMENT '序号',
  v_tbname varchar(100) COMMENT '表名',
  v_date varchar(6) COMMENT '转储年月',
  v_count_valuse DECIMAL(15,0) COMMENT '转储年月统计值',
  v_crc32_valuse DECIMAL(30,0) COMMENT '转储年月crc32校验值',
  v_timestamp timestamp DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '此列更新时间'
) COMMENT='原表信息统计';
```
这条语句在 `testdb` 数据库中创建了 `source_table`，用于存储原表的信息统计。

#### 3.4 创建 target_table：

```sql
create table testdb.target_table (
  v_id int COMMENT '序号',
  v_tbname varchar(100) COMMENT '表名',
  v_date varchar(6) COMMENT '转储年月',
  v_count_valuse DECIMAL(15,0) COMMENT '转储年月统计值',
  v_crc32_valuse DECIMAL(30,0) COMMENT '转储年月crc32校验值',
  v_exec varchar(6) COMMENT '转储年月执行时间',
  v_timestamp timestamp DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '此列更新时间'
) COMMENT='目标表信息统计';
```
这条语句在 `testdb` 数据库中创建了 `target_table`，用于存储目标表的信息统计。

这两个表的结构很相似，主要区别在于 `target_table` 多了一个 `v_exec` 列用于记录执行时间。

**一些注意事项：**

- 两个表都使用了 `COMMENT` 来为表和列添加注释，这有助于理解表的结构和用途。

- `v_timestamp` 列在两个表中都设置了自动更新的特性，这有助于跟踪记录的最后更新时间。

- `v_date` 列使用 `varchar(6)` 类型，可能是用来存储 YYYYMM 格式的年月。如果需要更复杂的日期操作，可以考虑使用 DATE 类型。

- `v_count_valuse` 和 `v_crc32_valuse` 使用 DECIMAL 类型，这对于存储精确的数值很有用。

- 表名前面都加了 `testdb.`，可以避免在多数据库环境中的歧义。

这些表看起来是为了跟踪和比较数据迁移或复制过程中的数据完整性和一致性。如果您需要对这些表结构进行任何修改或有任何其他问题，

### 4. 创建脚本环境；

```bash
#!/bin/bash
# File_name: 00.environment_variable.sh
# Usage:./00.environment_variable.sh
# Author: ze wen
# Date: 2024-09-28
# Description: GBase8a 8512版本,脚本变量.
# Version: 1.1

set -eo pipefail

# 文件目录变量
readonly HOME_PATH="/home/gbase/script"
readonly CONF="${HOME_PATH}/conf"
readonly LOGS="${HOME_PATH}/logs"  # 修复：添加 readonly
readonly BIN="${HOME_PATH}/bin"
readonly DATA="${HOME_PATH}/data"

# 确保日志目录存在
mkdir -p "$LOGS"

#时间取值
readonly DATE=$(date "+%Y%m%d")

# 使用关联数组定义日志文件
declare -rA LOG_FILES=(
    [CREATE]="${LOGS}/create.log"
    [DUMP]="${LOGS}/dump.log"
    [VERIFY]="${LOGS}/verify.log"
    [ALL]="${LOGS}/all_gbase.log"
)

# 日志函数
log() {
    local level=$1
    local type=$2
    local message=$3
    local timestamp=$(date "+%Y-%m-%d %H:%M:%S")
    
    echo "$timestamp [$level] $message" | tee -a "${LOG_FILES[$type]}" "${LOG_FILES[ALL]}"
}

echo "cat 日志文件路径: ${LOG_FILES[ALL]}"
# 日志函数示例
#log "$1" "$2" "$3"
#log "INFO" "CREATE" "Environment variables set successfully"

# 文件路径变量
readonly DATE_LIST="${CONF}/date_create.list"
readonly SC_TABLE_LIST="${CONF}/sc_table_create.list"
readonly TG_TABLE_LIST="${CONF}/tg_table_create.list"
readonly S_TABLE_INSERT="${DATA}/01.01_s_table_insert_data_create.sql"
readonly T_TABLE_INSERT="${DATA}/01.02_t_table_insert_data_create.sql"

# 创建必要的文件
create_file_if_not_exists() {
    local file="$1"
    if [[ ! -f "$file" ]]; then
        touch "$file" || { log "ERROR" "Failed to create file: $file"; exit 1; }
        log "INFO" "CREATE" "File created: $file"
    else
        log "INFO" "CREATE" "File already exists: $file"
    fi
}

# 创建必要的文件
create_file_if_not_exists "$DATE_LIST"
create_file_if_not_exists "$SC_TABLE_LIST"
create_file_if_not_exists "$TG_TABLE_LIST"

log "INFO" "CREATE" "Environment variables set successfully"
log "INFO" "CREATE" "Profile result path"
ls -1 | printf '%s\n' ${CONF}/* | tee -a "${LOG_FILES[CREATE]}" "${LOG_FILES[ALL]}"
ls -1 | printf '%s\n' ${DATA}/* | tee -a "${LOG_FILES[CREATE]}" "${LOG_FILES[ALL]}"
```

详细解释的脚本：

#### 4.1 脚本注释说明

```bash
#!/bin/bash
# File_name: 00.environment_variable.sh
# Usage:./00.environment_variable.sh
# Author: ze wen
# Date: 2024-09-28
# Description: GBase8a 8512版本,脚本变量.
# Version: 1.1
```
这部分提供了脚本的基本信息，包括用途、作者、日期和版本。

#### 4.2 脚本主体说明

**(1)  错误处理设置：**

```bash
set -eo pipefail
```
- `-e`：如果任何命令失败（返回非零退出码），脚本立即退出。
- `-o pipefail`：使得管道中的任何命令失败都会导致整个管道失败。

**(2)  目录变量定义：**

```bash
readonly HOME_PATH="/home/gbase/script"
readonly CONF="${HOME_PATH}/conf"
readonly LOGS="${HOME_PATH}/logs"
readonly BIN="${HOME_PATH}/bin"
readonly DATA="${HOME_PATH}/data"
```
定义了主要的目录路径，使用 `readonly` 防止意外修改。

**(3)  日志文件定义：**

```bash
# 使用关联数组定义日志文件
declare -rA LOG_FILES=(
    [CREATE]="${LOGS}/create.log"
    [DUMP]="${LOGS}/dump.log"
    [VERIFY]="${LOGS}/verify.log"
    [ALL]="${LOGS}/all_gbase.log"
)
```
定义了日志文件的路径，使用数组存储多个日志文件。

**(4)  日志函数：**

```bash
# 日志函数
log() {
    local level=$1
    local type=$2
    local message=$3
    local timestamp=$(date "+%Y-%m-%d %H:%M:%S")
    
    echo "$timestamp [$level] $message" | tee -a "${LOG_FILES[$type]}" "${LOG_FILES[ALL]}"
}

echo "cat 日志文件路径: ${LOG_FILES[ALL]}"
# 日志函数示例
#log "$1" "$2" "$3"
#log "INFO" "CREATE" "Environment variables set successfully"
```
这个函数用于记录日志，支持不同的日志级别，并将日志同时输出到屏幕和文件。

**(5)  其他文件路径定义：**

```bash
# 文件路径变量
readonly DATE_LIST="${CONF}/date_create.list"
readonly SC_TABLE_LIST="${CONF}/sc_table_create.list"
readonly TG_TABLE_LIST="${CONF}/tg_table_create.list"
readonly S_TABLE_INSERT="${DATA}/01.01_s_table_insert_data_create.sql"
readonly T_TABLE_INSERT="${DATA}/01.02_t_table_insert_data_create.sql"
```
定义了其他重要文件的路径。

**(6)  文件创建函数：**

```bash
# 创建必要的文件
create_file_if_not_exists() {
    local file="$1"
    if [[ ! -f "$file" ]]; then
        touch "$file" || { log "ERROR" "Failed to create file: $file"; exit 1; }
        log "INFO" "CREATE" "File created: $file"
    else
        log "INFO" "CREATE" "File already exists: $file"
    fi
}
```
这个函数检查文件是否存在，如果不存在则创建，并记录相应的日志。

**(7)  创建必要的文件：**

```bash
create_file_if_not_exists "$DATE_LIST"
create_file_if_not_exists "$SC_TABLE_LIST"
create_file_if_not_exists "$TG_TABLE_LIST"
```
使用上面定义的函数创建必要的文件。

**(8)  最后的确认日志：**

```bash
log "INFO" "CREATE" "Environment variables set successfully"
log "INFO" "CREATE" "Profile result path"
ls -1 | printf '%s\n' ${CONF}/* | tee -a "${LOG_FILES[CREATE]}" "${LOG_FILES[ALL]}"
ls -1 | printf '%s\n' ${DATA}/* | tee -a "${LOG_FILES[CREATE]}" "${LOG_FILES[ALL]}"
```
记录一条日志，表示环境变量设置成功。

这个脚本为其他脚本提供了一个健壮的环境设置基础。它定义了重要的路径和变量，设置了日志记录机制，并确保了必要文件的存在。通过使用函数和错误检查，它提高了代码的可维护性和可靠性。

### 5. 导入基础数据

#### **5.1  写入表信息**

```bash
# 原表信息
cat > /home/gbase/script/conf/sc_table_create.list
hds.hx_bafm42
hds.hx_glsfmgdat
hds.edzf_nxy_srl_cbnkaccg
hds.cg_bb_dw_gl_balance_d_f
hds.edzf_nxy_srl_book
hds.hx_glsfmfdtl
hds.hx_join_flow
hds.hx_pfsftpjrn
hds.hx_glsftgent
hds.hx_pfsftcjrn

# 目标表信息
cat > /home/gbase/script/conf/tg_table_create.list
hds.hx_bafm42_2024_bak_01
hds.hx_glsfmgdat_2024_bak_01
hds.edzf_nxy_srl_cbnkaccg_2024_bak_01
hds.cg_bb_dw_gl_balance_d_f_2024_bak_01
hds.edzf_nxy_srl_book_2024_bak_01
hds.hx_glsfmfdtl_2024_bak_01
hds.hx_join_flow_2024_bak_01
hds.hx_pfsftpjrn_2024_bak_01
hds.hx_glsftgent_2024_bak_01
hds.hx_pfsftcjrn_2024_bak_01
```

#### **5.2 生成插入数据SQL；**

注：设计时，不建议直接写入数据库。先生成文件确认无问题写入数据库；

```bash
#!/bin/bash
# File_name: 01.basic_data_sql.sh
# Usage:./01.basic_data_sql.sh
# Author: ze wen
# Date: 2024-09-28
# Description: GBase8a 8512版本,生成基本数据.
# Version: 1.1

set -eo pipefail

# 导入环境变量
source /home/gbase/script/bin/00.01_environment_variable.sh || { echo "Failed to source environment variables"; exit 1; }

# 年份和月份定义（可以通过参数传入）
YEAR_START=${1:-2018}
YEAR_END=${2:-2024}
YEAR=($(seq $YEAR_START $YEAR_END))
MONTH=(01 02 03 04 05 06 07 08 09 10 11 12)

# 函数：生成日期列表
generate_date_list() {
    > "$DATE_LIST"
    for Y in "${YEAR[@]}"; do
        for M in "${MONTH[@]}"; do
            echo "${Y}${M}" >> "$DATE_LIST"
        done
    done
    log "INFO" "CREATE" "Date list generated: $DATE_LIST"
}

echo "${DATE_LIST}"

# 函数：生成插入SQL
generate_insert_sql() {
    local table_list=$1
    local output_file=$2
    local table_type=$3
    local no=1

    > "$output_file"
    while IFS= read -r TB_NAME; do
        log "INFO" "CREATE" "Generating insert SQL for ${TB_SCHEMA}.${table_type}_table (${no},'${TB_NAME}')"
        while IFS= read -r V_DATE; do
            echo "insert into ${TB_SCHEMA}.${table_type}_table (v_id,v_tbname,v_date) values (${no},'${TB_NAME}','${V_DATE}');" >> "$output_file"
        done < "$DATE_LIST"
        ((no++))
    done < "$table_list"
    log "INFO" "CREATE" "Insert SQL generated for $table_type tables: $output_file"
}

# 主函数
main() {
    log "INFO" "CREATE" "Starting basic data generation"

    generate_date_list

    generate_insert_sql "$SC_TABLE_LIST" "$S_TABLE_INSERT" "source"
    generate_insert_sql "$TG_TABLE_LIST" "$T_TABLE_INSERT" "target"

    # 统计结果
    local sc_table_count=$(wc -l < "$SC_TABLE_LIST")
    local tg_table_count=$(wc -l < "$TG_TABLE_LIST")
    local st_count=$(wc -l < "$S_TABLE_INSERT")
    local tg_count=$(wc -l < "$T_TABLE_INSERT")
    local start_year=$(head -n 1 "$DATE_LIST")
    local end_of_year=$(tail -n 1 "$DATE_LIST")

    log "INFO" "CREATE" "Statistics:"
    log "INFO" "CREATE" "Source tables: $sc_table_count, Entries: $st_count"
    log "INFO" "CREATE" "Target tables: $tg_table_count, Entries: $tg_count"
    log "INFO" "CREATE" "Date range: $start_year to $end_of_year"

    log "INFO" "CREATE" "Data generation completed successfully"
    log "INFO" "CREATE" "Source table SQL: $S_TABLE_INSERT"
    log "INFO" "CREATE" "Target table SQL: $T_TABLE_INSERT"
}

# 执行主函数
main

log "INFO" "CREATE" "Script execution completed"
```

基本流程：

```bash
[开始] → [导入环境变量] → [设置年份和月份范围] → [生成日期列表] → [生成插入 SQL（源表）] → [生成插入 SQL（目标表）] → [统计结果] → [记录统计信息] → [结束]
```

脚本是用于生成基本数据的，主要用于GBase8a 8512版本的数据库操作。详细解析一下这个脚本的结构和功能：

这行代码是一个更加健壮的环境变量导入方式，它包含了错误处理机制。让我详细解释一下：

##### **(1)  调用环境变量值：**

```bash
source /home/gbase/script/bin/00.01_environment_variable.sh || { echo "Failed to source environment variables"; exit 1; }
```
**`source` 命令**

- `source` 命令（在某些 shell 中也可以用 `.` 代替）用于在当前 shell 环境中执行指定的脚本。
- 这里它执行了 `00.01_environment_variable.sh` 文件，该文件应该包含环境变量的定义。
- 使用 `source` 而不是直接执行脚本，确保变量在当前 shell 环境中可用。

**`||` （逻辑或运算符）**

- 如果前面的命令（source）失败（返回非零退出状态），则执行 `||` 后面的命令。

`{ echo "Failed to source environment variables"; exit 1; }`

- 这是一个命令组，在 source 命令失败时执行。
- `echo "Failed to source environment variables"` 输出错误消息。
- `exit 1` 使脚本以非零状态退出，表示发生了错误。

**代码的重要性：**

1. 错误处理：立即捕获并处理环境变量导入失败的情况。
2. 明确反馈：如果导入失败，提供清晰的错误消息。
3. 防止继续执行：如果关键的环境设置失败，阻止脚本继续运行，避免后续可能的错误。
4. 简洁性：在一行中完成了导入、错误检查和处理。

**使用建议：**

1. 确保 `00.01_environment_variable.sh` 文件存在且有正确的权限。
2. 在 `00.01_environment_variable.sh` 中使用 `export` 关键字定义变量，以确保它们在子进程中也可用。
3. 考虑在 `00.01_environment_variable.sh` 中添加自己的错误检查，例如检查必要的目录是否存在。

示例 `00.01_environment_variable.sh` 内容：

```bash
# 文件目录变量
readonly HOME_PATH="/home/gbase/script"
readonly CONF="${HOME_PATH}/conf"
readonly LOGS="${HOME_PATH}/logs"  # 修复：添加 readonly
readonly BIN="${HOME_PATH}/bin"
readonly DATA="${HOME_PATH}/data"

# 文件路径变量
readonly DATE_LIST="${CONF}/date_create.list"
readonly SC_TABLE_LIST="${CONF}/sc_table_create.list"
readonly TG_TABLE_LIST="${CONF}/tg_table_create.list"
readonly S_TABLE_INSERT="${DATA}/01.01_s_table_insert_data_create.sql"
readonly T_TABLE_INSERT="${DATA}/01.02_t_table_insert_data_create.sql"

# 数据库变量
readonly TB_SCHEMA="testdb"
```

##### **(2)  年月参数生成**

```bash
# 年份和月份定义（可以通过参数传入）
YEAR_START=${1:-2018}
YEAR_END=${2:-2024}
YEAR=($(seq $YEAR_START $YEAR_END))
MONTH=(01 02 03 04 05 06 07 08 09 10 11 12)
```

这段代码定义了年份和月份的范围，并允许通过命令行参数来自定义年份范围。让我详细解释每一行：

1. **`YEAR_START=${1:-2018}`**
   - 这行设置起始年份。
   - `${1:-2018}` 意味着：如果提供了第一个命令行参数 (`$1`)，就使用它；否则，默认使用 2018。
   - 这种写法允许用户在运行脚本时指定起始年份，如果没有指定，则使用默认值 2018。

2. **`YEAR_END=${2:-2024}`**
   - 类似地，这行设置结束年份。
   - 如果提供了第二个命令行参数 (`$2`)，就使用它；否则，默认使用 2024。

3. **`YEAR=($(seq $YEAR_START $YEAR_END))`**
   - 这行创建了一个包含从 `YEAR_START` 到 `YEAR_END` 的所有年份的数组。
   - `seq $YEAR_START $YEAR_END` 生成一个从起始年份到结束年份的序列。
   - `$( ... )` 是命令替换，它执行括号内的命令并返回结果。
   - `YEAR=( ... )` 将结果赋值给 YEAR 数组。

4. **`MONTH=(01 02 03 04 05 06 07 08 09 10 11 12)`**
   - 这行定义了一个包含所有月份（用两位数表示）的数组。

这段代码的优点：

1. 灵活性：允许用户通过命令行参数自定义年份范围。
2. 默认值：如果没有提供参数，使用预设的默认值。
3. 动态生成：使用 `seq` 命令动态生成年份序列，而不是硬编码。
4. 数组使用：将年份和月份存储在数组中，便于后续处理。

使用示例：

- 使用默认值：`./script.sh`
- 自定义年份范围：`./script.sh 2020 2025`

这种设计使脚本更加灵活和可重用，允许用户根据需要生成不同时间范围的数据，而无需修改脚本本身。同时，它也为脚本提供了合理的默认行为。

##### **(3)  主体函数说明**

######  `generate_date_list` 函数

用于生成日期列表。详细解释这个函数的结构和功能：

```bash
# 函数：生成日期列表
generate_date_list() {
    > "$DATE_LIST"
    for Y in "${YEAR[@]}"; do
        for M in "${MONTH[@]}"; do
            echo "${Y}${M}" >> "$DATE_LIST"
        done
    done
    log "INFO" "CREATE" "Date list generated: $DATE_LIST"
}

echo "${DATE_LIST}"
```

1. **函数定义：**
   
   ```bash
   generate_date_list() {
       # 函数内容
   }
   ```
   这定义了一个名为 `generate_date_list` 的函数。
   
2. **清空或创建日期列表文件：**
   
   ```bash
   > "$DATE_LIST"
   #源变量为：readonly DATE_LIST="${CONF}/date_create.list"
   ```
   这行代码清空 `$DATE_LIST` 文件（如果存在），或创建一个新的空文件（如果不存在）。`$DATE_LIST` 是一个变量，应该在环境变量文件中定义，指向日期列表文件的路径。
   
3. **嵌套循环生成日期：**
   
   ```bash
   for Y in "${YEAR[@]}"; do
       for M in "${MONTH[@]}"; do
           echo "${Y}${M}" >> "$DATE_LIST"
       done
   done
   ```
   - 外层循环遍历 `YEAR` 数组中的每一年。
   - 内层循环遍历 `MONTH` 数组中的每一月。
   - 对于每个年月组合，生成一个格式为 "YYYYMM" 的日期字符串。
   - 将每个生成的日期追加到 `$DATE_LIST` 文件中。
   
4. **日志记录：**
   
   ```bash
   log "INFO" "CREATE" "Date list generated: $DATE_LIST"
   #本次记录到[CREATE]="${LOGS}/create.log
   ```
   使用 `log` 函数（应在环境变量文件中定义）记录日期列表生成完成的信息。
   
5. **函数外的 echo 语句：**
   
   ```bash
   echo "${DATE_LIST}"
   ```
   这行代码在函数定义之外，它会输出 `$DATE_LIST` 变量的值，即日期列表文件的路径。

**这个函数的主要特点和用途：**

- 灵活性：可以根据之前定义的年份和月份范围生成日期列表。
- 文件操作：将生成的日期写入文件，便于后续处理和重用。
- 日志记录：提供了操作完成的日志，有助于跟踪脚本执行过程。
- 清晰结构：使用函数封装逻辑，提高代码的可读性和可维护性。

使用这个函数可以方便地生成一个包含指定年份范围内所有月份的日期列表。这在数据库操作、报告生成或其他需要处理时间序列数据的场景中非常有用。

**注意：确保在调用这个函数之前，`$DATE_LIST`、`YEAR` 和 `MONTH` 变量已经正确定义。**

######  `generate_insert_sql` 函数

用于生成插入 SQL 语句。详细解释这个函数的结构和功能：

```bash
# 函数：生成插入SQL
generate_insert_sql() {
    local table_list=$1
    local output_file=$2
    local table_type=$3
    local no=1

    > "$output_file"
    while IFS= read -r TB_NAME; do
        log "INFO" "CREATE" "Generating insert SQL for ${TB_SCHEMA}.${table_type}_table (${no},'${TB_NAME}')"
        while IFS= read -r V_DATE; do
            echo "insert into ${TB_SCHEMA}.${table_type}_table (v_id,v_tbname,v_date) values (${no},'${TB_NAME}','${V_DATE}');" >> "$output_file"
        done < "$DATE_LIST"
        ((no++))
    done < "$table_list"
    log "INFO" "CREATE" "Insert SQL generated for $table_type tables: $output_file"
}
```

1. **函数参数：**
   
   - `$1` (`table_list`): 包含表名的文件路径: 
   
     ```bash
     readonly SC_TABLE_LIST="${CONF}/sc_table_create.list"
     readonly TG_TABLE_LIST="${CONF}/tg_table_create.list"
     ```
   
   - `$2` (`output_file`): 生成的 SQL 语句将被写入的文件路径
   
     ```bash
     readonly S_TABLE_INSERT="${DATA}/01.01_s_table_insert_data_create.sql"
     readonly T_TABLE_INSERT="${DATA}/01.02_t_table_insert_data_create.sql"
     ```
   
   - `$3` (`table_type`): 表类型（指 "source" 或 "target"）
   
2. **局部变量：**
   
   - `local no=1`: 初始化一个计数器，用于生成唯一的 `v_id`
   
3. **清空输出文件：**
   
   - `> "$output_file"`: 确保输出文件是空的，防止追加到旧内容
   
4. **外层循环（处理每个表）：**
   
   ```bash
   while IFS= read -r TB_NAME; do
       ...
   done < "$table_list"
   ```
   - 读取 `table_list` 文件中的每一行（每个表名）
   - `IFS=` 和 `read -r` 确保正确读取可能包含空格的表名

 while 循环，用于逐行读取文件内容。让详细解释一下这个结构：

- `while` 循环：
   - 这个循环会一直执行，直到 `read` 命令返回非零状态（通常是到达文件末尾）。

- `IFS=`：
   - IFS 是 "Internal Field Separator" 的缩写，用于定义字段分隔符。
   - 将 IFS 设置为空字符串可以防止 `read` 命令去除行首和行尾的空白字符。
   - 这确保了读取的内容完全保留原始格式，包括可能的前导或尾随空格。

- `read -r TB_NAME`：
   - `read` 命令用于从输入中读取一行。
   - `-r` 选项防止反斜杠 `\` 被解释为转义字符。这对于处理可能包含反斜杠的文本很重要。
   - `TB_NAME` 是一个变量名，每次循环时，读取的行内容会被存储在这个变量中。

- `do ... done`：
   - 这定义了循环体，包含了每次迭代要执行的命令。

- `< "$table_list"`：
   - 这是输入重定向，告诉 `while` 循环从 `$table_list` 文件中读取内容。
   - `$table_list` 是一个变量，包含了要读取的文件的路径。

5. **内层循环（处理每个日期）：**

```bash
while IFS= read -r V_DATE; do
    ...
done < "$DATE_LIST"
```
- 读取 `DATE_LIST` 文件中的每一行（每个日期）

6. **生成插入语句：**

```bash
echo "insert into ${TB_SCHEMA}.${table_type}_table (v_id,v_tbname,v_date) values (${no},'${TB_NAME}','${V_DATE}');" >> "$output_file"
```
- 为每个表和每个日期组合生成一条 INSERT 语句
- 使用 `>>` 追加到输出文件

7. **递增计数器：**

- `((no++))`: 每处理完一个表就增加计数器

8. **最终日志：**

- 记录 SQL 生成完成的信息

**这个函数的主要特点：**

1. 灵活性：可以用于生成不同类型的表（源表或目标表）的插入语句。
2. 效率：通过文件读取和写入，可以处理大量数据。
3. 唯一性：使用递增的 `no` 确保每条记录有唯一的 `v_id`。
4. 错误处理：使用 `IFS=` 和 `read -r` 安全地处理包含空格的表名。
5. 日志记录：提供了详细的进度日志。

这个函数非常适合批量生成大量插入语句，特别是在准备测试数据或进行数据迁移时。它的设计允许轻松修改或扩展，以适应不同的数据库结构和需求。

######  `main()` 函数

主要执行部分，它协调了整个数据生成过程。详细解释这个函数的结构和功能：

```bash
# 主函数
main() {
    log "INFO" "CREATE" "Starting basic data generation"

    generate_date_list

    generate_insert_sql "$SC_TABLE_LIST" "$S_TABLE_INSERT" "source"
    generate_insert_sql "$TG_TABLE_LIST" "$T_TABLE_INSERT" "target"

    # 统计结果
    local sc_table_count=$(wc -l < "$SC_TABLE_LIST")
    local tg_table_count=$(wc -l < "$TG_TABLE_LIST")
    local st_count=$(wc -l < "$S_TABLE_INSERT")
    local tg_count=$(wc -l < "$T_TABLE_INSERT")
    local start_year=$(head -n 1 "$DATE_LIST")
    local end_of_year=$(tail -n 1 "$DATE_LIST")

    log "INFO" "CREATE" "Statistics:"
    log "INFO" "CREATE" "Source tables: $sc_table_count, Entries: $st_count"
    log "INFO" "CREATE" "Target tables: $tg_table_count, Entries: $tg_count"
    log "INFO" "CREATE" "Date range: $start_year to $end_of_year"

    log "INFO" "CREATE" "Data generation completed successfully"
    log "INFO" "CREATE" "Source table SQL: $S_TABLE_INSERT"
    log "INFO" "CREATE" "Target table SQL: $T_TABLE_INSERT"
}
```

1. **开始日志：**
   
   ```bash
   log "INFO" "CREATE" "Starting basic data generation"
   ```
   记录数据生成过程开始。
   
2. **生成日期列表：**
   
   ```bash
   generate_date_list
   ```
   调用之前定义的 `generate_date_list` 函数来创建日期列表。
   
3. **生成插入 SQL：**
   
   ```bash
   generate_insert_sql "$SC_TABLE_LIST" "$S_TABLE_INSERT" "source"
   generate_insert_sql "$TG_TABLE_LIST" "$T_TABLE_INSERT" "target"
   ```
   为源表和目标表分别调用 `generate_insert_sql` 函数生成插入 SQL 语句。
   
4. **统计结果：**
   
   ```bash
   local sc_table_count=$(wc -l < "$SC_TABLE_LIST")
   local tg_table_count=$(wc -l < "$TG_TABLE_LIST")
   local st_count=$(wc -l < "$S_TABLE_INSERT")
   local tg_count=$(wc -l < "$T_TABLE_INSERT")
   local start_year=$(head -n 1 "$DATE_LIST")
   local end_of_year=$(tail -n 1 "$DATE_LIST")
   ```
   - 计算源表和目标表的数量。
   - 计算生成的 SQL 语句数量。
   - 获取日期范围的开始和结束年份。
   
5. **记录统计信息：**
   
   ```bash
   log "INFO" "CREATE" "Statistics:"
   log "INFO" "CREATE" "Source tables: $sc_table_count, Entries: $st_count"
   log "INFO" "CREATE" "Target tables: $tg_table_count, Entries: $tg_count"
   log "INFO" "CREATE" "Date range: $start_year to $end_of_year"
   ```
   使用 `log` 函数记录统计信息。
   
6. **完成日志：**
   
   ```bash
   log "INFO" "CREATE" "Data generation completed successfully"
   log "INFO" "CREATE" "Source table SQL: $S_TABLE_INSERT"
   log "INFO" "CREATE" "Target table SQL: $T_TABLE_INSERT"
   ```
   记录数据生成完成的信息和生成的 SQL 文件位置。

**这个 `main()` 函数的主要特点：**

1. 结构化：清晰地组织了整个数据生成过程的步骤。
2. 日志记录：详细记录了每个步骤和最终结果，便于跟踪和调试。
3. 统计功能：提供了生成数据的统计信息，有助于验证结果。
4. 模块化：通过调用其他函数来完成具体任务，提高了代码的可读性和可维护性。
5. 灵活性：可以轻松扩展以包含更多的数据处理步骤。

这个函数为整个脚本提供了一个清晰的执行流程，从日期列表生成到 SQL 语句创建，再到结果统计，都有条理地组织在一起。这种结构使得脚本易于理解、维护和扩展。

### 6. 数据库导入基本信息

```sql
gccli -uadmin -padmin < /home/gbase/gbase_dump_process/data/01.01_s_table_insert_data.sql;
gccli -uadmin -padmin < /home/gbase/gbase_dump_process/data/01.02_t_table_insert_data.sql;

-- 注：truncate testdb.source_table;truncate testdb.target_table;
gccli -uadmin -padmin -e "select count(1) from testdb.source_table;"
gccli -uadmin -padmin -e "select count(1) from testdb.target_table;"
```

# 二、转储数据

### 1. 创建目标表（表结构与原表完成一致）

```sql
#创建目标表（表结构与原表完成一致）
create table hds.hx_bafm42_2024_bak_01 like hds.hx_bafm42;
create table hds.hx_glsfmgdat_2024_bak_01 like hds.hx_glsfmgdat;
create table hds.edzf_nxy_srl_cbnkaccg_2024_bak_01 like hds.edzf_nxy_srl_cbnkaccg;
create table hds.cg_bb_dw_gl_balance_d_f_2024_bak_01 like hds.cg_bb_dw_gl_balance_d_f;
create table hds.edzf_nxy_srl_book_2024_bak_01 like hds.edzf_nxy_srl_book;
create table hds.hx_glsfmfdtl_2024_bak_01 like hds.hx_glsfmfdtl;
create table hds.hx_join_flow_2024_bak_01 like hds.hx_join_flow;
create table hds.hx_pfsftpjrn_2024_bak_01 like hds.hx_pfsftpjrn;
create table hds.hx_glsftgent_2024_bak_01 like hds.hx_glsftgent;
create table hds.hx_pfsftcjrn_2024_bak_01 like hds.hx_pfsftcjrn;
```

这段SQL代码创建了一系列新表，每个新表都是基于现有表的结构。让我为您解析这些SQL语句：

#### **(1)  语法结构：**

```sql
create table 新表名 like 原表名;
```
这种语法会创建一个与原表结构完全相同的新表，包括所有列定义、索引、约束等，但不会复制数据。

#### **(2)  命名模式：**

- 所有新表都在 `hds` 模式（schema）下。
- 新表名格式为：原表名_2024_bak_01
- 这种命名可能表示这些是2024年的备份表或临时表。

#### **(3)  具体表：**

- `hx_bafm42_2024_bak_01` 基于 `hx_bafm42`
- `hx_glsfmgdat_2024_bak_01` 基于 `hx_glsfmgdat`
- `edzf_nxy_srl_cbnkaccg_2024_bak_01` 基于 `edzf_nxy_srl_cbnkaccg`
- `cg_bb_dw_gl_balance_d_f_2024_bak_01` 基于 `cg_bb_dw_gl_balance_d_f`
- `edzf_nxy_srl_book_2024_bak_01` 基于 `edzf_nxy_srl_book`
- `hx_glsfmfdtl_2024_bak_01` 基于 `hx_glsfmfdtl`
- `hx_join_flow_2024_bak_01` 基于 `hx_join_flow`
- `hx_pfsftpjrn_2024_bak_01` 基于 `hx_pfsftpjrn`
- `hx_glsftgent_2024_bak_01` 基于 `hx_glsftgent`
- `hx_pfsftcjrn_2024_bak_01` 基于 `hx_pfsftcjrn`

**这些SQL语句的目的可能是：**

1. 创建备份表以存储2024年的数据。
2. 为数据迁移或重组准备新的表结构。
3. 创建临时表用于数据处理或测试。

**注意事项：**

- 这些新表初始时是空的，不包含原表的数据。
- 如果原表有任何触发器、外键约束或某些特定的表属性，可能需要单独处理。
- 确保有足够的存储空间来创建这些新表。
- 在生产环境中执行这些操作时要小心，可能需要在维护窗口或低峰期进行。

如果您需要同时复制数据，可以考虑使用 `CREATE TABLE AS SELECT` 语法或在创建表后使用 `INSERT INTO ... SELECT` 语句。

### 2.  表结构对比

![image-20241001094611613](/Users/yue/Library/Application Support/typora-user-images/image-20241001094611613.png)

```bash
#!/bin/bash
# File_name: 02.table_structure.sh
# Usage:./02.table_structure.sh
# Author: ze wen
# Date: 2024-09-28
# Description: GBase8a 8512版本,原表与目标表，表结构对比.
# Version: 1.1

set -eo pipefail

# 导入环境变量
source /home/gbase/script/bin/00.01_environment_variable.sh || { echo "Failed to source environment variables"; exit 1; }

# 清空输出文件
: > "${S_TABLE_CRAETE}"
: > "${T_TABLE_CRAETE}"

# 函数：执行SQL并记录输出
execute_sql() {
    local table=$1
    local output_file=$2
    log "INFO" "DUMP" "Executing: gccli -u${DB_USER} -p${DB_PASSWD} -e \"show create table ${table}\G;\""
    gccli -u"${DB_USER}" -p"${DB_PASSWD}" -e "show create table ${table}\G;" >> "${output_file}"
}

# 主函数
main() {
    while IFS= read -r TB_NAME; do
        execute_sql "${TB_NAME}" "${S_TABLE_CRAETE}"
        execute_sql "${TB_NAME}_2024_bak_01" "${T_TABLE_CRAETE}"
    done < "${SC_TABLE_LIST}"

    log "INFO" "DUMP" "Comparing table structures..."
    diff "${S_TABLE_CRAETE}" "${T_TABLE_CRAETE}" | grep -v "Create Table" | tee -a "${LOG_FILES[DUMP]}" "${LOG_FILES[ALL]}" || true

    log "INFO" "DUMP" "Table schema export completed successfully."
    log "INFO" "DUMP" "Exported data locations:"
    log "INFO" "DUMP" "Source table structure: ${S_TABLE_CRAETE}"
    log "INFO" "DUMP" "Target table structure: ${T_TABLE_CRAETE}"
    log "INFO" "DUMP" "Comparison log: ${LOG_FILES[ALL]}"
}

# 执行主函数
main

log "INFO" "DUMP" "Script execution completed."
echo "To view the full log, run: cat ${LOG_FILES[DUMP]}"
```

#### （1） `execute_sql` 函数

是一个很好的封装，用于执行 SQL 命令并记录输出。让我详细解析这个函数：

```bash
# 函数：执行SQL并记录输出
execute_sql() {
    local table=$1
    local output_file=$2
    log "INFO" "DUMP" "Executing: gccli -u${DB_USER} -p${DB_PASSWD} -e \"show create table ${table}\G;\""
    gccli -u"${DB_USER}" -p"${DB_PASSWD}" -e "show create table ${table}\G;" >> "${output_file}"
}
```

1. ##### **函数定义：**
   
   ```bash
   execute_sql() {
       # 函数体
   }
   ```
   定义了一个名为 `execute_sql` 的函数。
   
2. **参数处理：**
   
   ```bash
   local table=$1
   local output_file=$2
   ```
   - `local` 关键字声明局部变量，这是一个好习惯，防止变量污染全局命名空间。
   - `$1` 和 `$2` 分别是函数的第一个和第二个参数。
   - `table` 存储要查询的表名。
   - `output_file` 存储输出文件的路径。
   
3. **日志记录：**
   
   ```bash
   log "INFO" "DUMP" "Executing: gccli -u${DB_USER} -p${DB_PASSWD} -e \"show create table ${table}\G;\""
   ```
   - 使用 `log` 函数记录即将执行的命令。
   - 这有助于调试和跟踪脚本的执行过程。
   
4. **SQL 执行：**
   
   ```bash
   gccli -u"${DB_USER}" -p"${DB_PASSWD}" -e "show create table ${table}\G;" >> "${output_file}"
   ```
   - 使用 `gccli` 命令执行 SQL。
   - `-u` 和 `-p` 选项分别指定用户名和密码。
   - `-e` 选项后跟要执行的 SQL 命令。
   - `"show create table ${table}\G;"` 是实际的 SQL 命令，用于显示表的创建语句。
   - `\G` 是 MySQL/MariaDB 的特殊格式化选项，使输出垂直排列。
   - `>> "${output_file}"` 将输出追加到指定的文件中。

**函数的优点：**

1. 封装性好：将 SQL 执行逻辑封装在一个函数中，便于重用。
2. 参数化：通过参数传入表名和输出文件，增加了灵活性。
3. 日志记录：记录执行的命令，有助于调试和监控。
4. 使用局部变量：防止变量名冲突。

####  （2）`main()` 函数

```bash
# 主函数
main() {
    while IFS= read -r TB_NAME; do
        execute_sql "${TB_NAME}" "${S_TABLE_CRAETE}"
        execute_sql "${TB_NAME}_2024_bak_01" "${T_TABLE_CRAETE}"
    done < "${SC_TABLE_LIST}"

    log "INFO" "DUMP" "Comparing table structures..."
    diff "${S_TABLE_CRAETE}" "${T_TABLE_CRAETE}" | grep -v "Create Table" | tee -a "${LOG_FILES[DUMP]}" "${LOG_FILES[ALL]}" || true

    log "INFO" "DUMP" "Table schema export completed successfully."
    log "INFO" "DUMP" "Exported data locations:"
    log "INFO" "DUMP" "Source table structure: ${S_TABLE_CRAETE}"
    log "INFO" "DUMP" "Target table structure: ${T_TABLE_CRAETE}"
    log "INFO" "DUMP" "Comparison log: ${LOG_FILES[ALL]}"
}
```

这个 `main` 函数是脚本的核心部分，它协调了整个表结构比较的过程。让我详细分析这个函数的结构和功能：

1. 循环读取表名并执行 SQL：
   ```bash
   while IFS= read -r TB_NAME; do
       execute_sql "${TB_NAME}" "${S_TABLE_CRAETE}"
       execute_sql "${TB_NAME}_2024_bak_01" "${T_TABLE_CRAETE}"
   done < "${SC_TABLE_LIST}"
   ```
   - 使用 `while` 循环读取 `${SC_TABLE_LIST}` 文件中的每一行。
   - `IFS=` 确保读取整行，包括可能的空格。
   - 对每个表名执行两次 `execute_sql`，一次是原表，一次是备份表。

2. 比较表结构：
   ```bash
   log "INFO" "DUMP" "Comparing table structures..."
   diff "${S_TABLE_CRAETE}" "${T_TABLE_CRAETE}" | grep -v "Create Table" | tee -a "${LOG_FILES[DUMP]}" "${LOG_FILES[ALL]}" || true
   ```
   - 使用 `diff` 命令比较两个文件。
   - `grep -v "Create Table"` 过滤掉包含 "Create Table" 的行。
   - `tee -a` 将输出同时追加到两个日志文件。
   - `|| true` 确保即使 `diff` 发现差异（返回非零状态），脚本也会继续执行。

3. 记录完成信息：
   ```bash
   log "INFO" "DUMP" "Table schema export completed successfully."
   log "INFO" "DUMP" "Exported data locations:"
   log "INFO" "DUMP" "Source table structure: ${S_TABLE_CRAETE}"
   log "INFO" "DUMP" "Target table structure: ${T_TABLE_CRAETE}"
   log "INFO" "DUMP" "Comparison log: ${LOG_FILES[ALL]}"
   ```
   - 使用 `log` 函数记录操作完成的信息和相关文件的位置。

这个函数的优点：
1. 结构清晰：逻辑流程易于理解。
2. 错误处理：使用 `|| true` 防止 `diff` 命令导致脚本终止。
3. 详细日志：记录了每个步骤的信息，便于追踪和调试。

### 3. 数据导入

```bash
#!/bin/bash
# File_name: 03.01_Data_import_yyyy_mm_dd.sh
# Usage:./03.01_Data_import_yyyy_mm_dd.sh  <原库.表名> <列名> <年份> [开始月份] [结束月份]  
# 示例:./03.01_Data_import_yyyy_mm_dd.sh hds.hx_bafm42 BA42TXDT 2018 01 06  不加月份，默认为全年
# Author: ze wen
# Date: 2024-09-28
# Description: GBase8a 8512版本,原表向目标表，插入数据，并进行crc32校对数据，日期格式为:yyyy-mm-dd.
# Version: 1.0
set -eo pipefail

# 导入环境变量
source /home/gbase/script/bin/00.01_environment_variable.sh || { echo "Failed to source environment variables"; exit 1; }

# 参数检查
if [ $# -lt 3 ] || [ $# -gt 5 ]; then
    echo "Usage: $0 <原库.表名> <列名> <年份> [开始月份] [结束月份]"
    exit 1
fi

# 引入变量
SC_TB_NAME=$1
TG_TB_NAME="${1}_2024_bak_01"
COLUMN=$2
TB_YEAR=$3
START_MONTH=${4:-01}
END_MONTH=${5:-12}

# 生成月份数组
generate_months() {
    local start=$1
    local end=$2
    local months=()
    for ((i=start; i<=end; i++)); do
        months+=($(printf "%02d" $i))
    done
    echo "${months[@]}"
}

MONTHS=($(generate_months $START_MONTH $END_MONTH))

# 函数定义
execute_sql() {
    local query=$1
    local output=${2:-}
    if [ -n "$output" ]; then
        gccli -u"${DB_USER}" -p"${DB_PASSWD}" -vvv -e "$query" >> "$output"
    else
        gccli -u"${DB_USER}" -p"${DB_PASSWD}" -Ns -e "$query"
    fi
}

update_table_stats() {
    local table=$1
    local tbname=$2
    local date=$3
    local count=$4
    local crc32=${5:-}
    
    local query="UPDATE testdb.${table}_table SET v_count_valuse = $count"
    [ -n "$crc32" ] && query+=", v_crc32_valuse = $crc32"
    query+=" WHERE v_tbname = '${tbname}' AND v_date = '$date';"
    
    execute_sql "$query" "${LOG_FILES[DUMP]}"
}

generate_crc32_query() {
    local table=$1
    execute_sql "DESC $table;" | awk '{a = a "crc32(\""$1"\")+"} END {sub(/\+$/, "", a); print a}'
}

compare_tables() {
    local date=$1
    execute_sql "SELECT 
        sc.v_id, sc.v_tbname, sc.v_date,
        sc.v_count_valuse AS sc_count, tg.v_count_valuse AS tg_count,
        sc.v_crc32_valuse AS sc_crc32, tg.v_crc32_valuse AS tg_crc32,
        sc.v_crc32_valuse - tg.v_crc32_valuse AS diff_crc32, sc.v_timestamp
    FROM testdb.source_table AS sc 
    LEFT JOIN testdb.target_table AS tg ON sc.v_id = tg.v_id AND sc.v_date = tg.v_date
    WHERE sc.v_date = '$date' AND sc.v_tbname = '${SC_TB_NAME}';" "${LOG_FILES[DUMP]}"
}

select_tables() {
    local date=$1
    execute_sql "SELECT 
        sc.v_id, sc.v_tbname, sc.v_date,
        sc.v_count_valuse AS sc_count, tg.v_count_valuse AS tg_count,
        sc.v_crc32_valuse AS sc_crc32, tg.v_crc32_valuse AS tg_crc32,
        sc.v_crc32_valuse - tg.v_crc32_valuse AS diff_crc32, sc.v_timestamp
    FROM testdb.source_table AS sc 
    LEFT JOIN testdb.target_table AS tg ON sc.v_id = tg.v_id AND sc.v_date = tg.v_date
    WHERE sc.v_date like '$date' AND sc.v_tbname = '${SC_TB_NAME}';" "${LOG_FILES[DUMP]}" | tee -a "${LOG_FILES[DUMP]}" "${LOG_FILES[ALL]}"
}


# 主处理循环
for M in "${MONTHS[@]}"; do
    DATE="${TB_YEAR}${M}"
    log "INFO" "DUMP" "####################### ${SC_TB_NAME} [$DATE] Processing begin #######################"
    
    # 统计和更新原表数据
    log "INFO" "DUMP" "Update the table count result..."
    SC_COUNT=$(execute_sql "SELECT COUNT(1) FROM ${SC_TB_NAME} WHERE ${COLUMN} BETWEEN '${TB_YEAR}-${M}-01' AND LAST_DAY('${TB_YEAR}-${M}-01');")
    update_table_stats "source" "$SC_TB_NAME" "$DATE" "$SC_COUNT"
    compare_tables $DATE

    # 插入数据到目标表
    log "INFO" "DUMP" "Inserting data into target table..."
    execute_sql "INSERT INTO ${TG_TB_NAME} SELECT * FROM ${SC_TB_NAME} WHERE ${COLUMN} BETWEEN '${TB_YEAR}-${M}-01' AND LAST_DAY('${TB_YEAR}-${M}-01') ORDER BY ${COLUMN};" "${LOG_FILES[DUMP]}"
    
    # 统计和更新目标表数据
    log "INFO" "DUMP" "Update the count result of the target table..."
    TG_COUNT=$(execute_sql "SELECT COUNT(1) FROM ${TG_TB_NAME} WHERE ${COLUMN} BETWEEN '${TB_YEAR}-${M}-01' AND LAST_DAY('${TB_YEAR}-${M}-01');")
    update_table_stats "target" "$TG_TB_NAME" "$DATE" "$TG_COUNT"
    compare_tables $DATE
    # CRC32 验证
    log "INFO" "DUMP" "Performing CRC32 verification..."
    SOURCE_CRC32_QUERY=$(generate_crc32_query "${SC_TB_NAME}")
    TARGET_CRC32_QUERY=$(generate_crc32_query "${TG_TB_NAME}")
    
    SOURCE_CRC32=$(execute_sql "SELECT SUM($SOURCE_CRC32_QUERY) FROM ${SC_TB_NAME} WHERE ${COLUMN} BETWEEN '${TB_YEAR}-${M}-01' AND LAST_DAY('${TB_YEAR}-${M}-01');")
    TARGET_CRC32=$(execute_sql "SELECT SUM($TARGET_CRC32_QUERY) FROM ${TG_TB_NAME} WHERE ${COLUMN} BETWEEN '${TB_YEAR}-${M}-01' AND LAST_DAY('${TB_YEAR}-${M}-01');")

    update_table_stats "source" "$SC_TB_NAME" "$DATE" "$SC_COUNT" "$SOURCE_CRC32"
    update_table_stats "target" "$TG_TB_NAME" "$DATE" "$TG_COUNT" "$TARGET_CRC32"

    # 比较结果
    compare_tables "$DATE"

    log "INFO" "DUMP" "####################### ${SC_TB_NAME} [$DATE] Processing end #######################"
done

# 年度总结
log "INFO" "DUMP" "Summary for ${TB_YEAR} from month $START_MONTH to $END_MONTH:"
select_tables "${TB_YEAR}%"

log "INFO" "DUMP" "Processing completed. Log file: ${LOG_FILES[DUMP]}"
```



#### 3.1 引入变量

允许用户指定要处理的月份范围。详细解析这段代码：

```bash
# 引入变量
SC_TB_NAME=$1
TG_TB_NAME="${1}_2024_bak_01"
COLUMN=$2
TB_YEAR=$3
START_MONTH=${4:-01}
END_MONTH=${5:-12}

# 生成月份数组
generate_months() {
    local start=$1
    local end=$2
    local months=()
    for ((i=start; i<=end; i++)); do
        months+=($(printf "%02d" $i))
    done
    echo "${months[@]}"
}
MONTHS=($(generate_months $START_MONTH $END_MONTH))
```

##### **（1）变量赋值：**

```bash
SC_TB_NAME=$1
TG_TB_NAME="${1}_2024_bak_01"
COLUMN=$2
TB_YEAR=$3
START_MONTH=${4:-01}
END_MONTH=${5:-12}
```
使用命令行参数设置变量。

- 使用参数扩展为 `START_MONTH` 和 `END_MONTH` 提供默认值。
- `${4:-01}` 和 `${5:-12}` 使用了参数扩展，如果第4和第5个参数没有提供，则默认值分别为 "01" 和 "12"。

##### **（2）`generate_months` 函数：**

```bash
generate_months() {
    local start=$1
    local end=$2
    local months=()
    for ((i=start; i<=end; i++)); do
        months+=($(printf "%02d" $i))
    done
    echo "${months[@]}"
}
```

它允许用户灵活地指定要处理的月份范围。

- 接受开始和结束月份作为参数。
- 使用循环生成月份数组。
- 使用 `printf` 确保月份为两位数格式。

##### （3）生成月份数组：

```bash
MONTHS=($(generate_months $START_MONTH $END_MONTH))
```
- 调用 `generate_months` 函数并将结果存储在 `MONTHS` 数组中。

**这段代码的优点：**

- 灵活性：允许处理任意月份范围。
- 默认行为：如果不指定月份，默认处理整年。
- 代码复用：`generate_months` 函数可在其他地方重用。
- 可读性：代码结构清晰，易于理解。

**使用这段代码，可以这样调用脚本：**

- 处理整年：
  ```bash
  ./script.sh table_name column_name 2023
  ```
- 处理特定月份范围：
  ```bash
  ./script.sh table_name column_name 2023 03 06
  ```
- 处理单个月份：
  ```bash
  ./script.sh table_name column_name 2023 07 07
  ```

####  **3.2  `execute_sql` 函数**

是一个非常实用的封装，用于执行 SQL 查询并处理输出。详细分析这个函数：

```bash
# 函数定义
execute_sql() {
    local query=$1
    local output=${2:-}
    if [ -n "$output" ]; then
        gccli -u"${DB_USER}" -p"${DB_PASSWD}" -vvv -e "$query" >> "$output"
    else
        gccli -u"${DB_USER}" -p"${DB_PASSWD}" -Ns -e "$query"
    fi
}
```

##### （1）函数定义：

```bash
execute_sql() {
    # 函数体
}
```

##### （2）参数处理：

```bash
local query=$1
local output=${2:-}
```
- `query`: 第一个参数，存储要执行的 SQL 查询。
- `output`: 第二个参数（可选），用于指定输出文件。使用 `${2:-}` 语法，如果没有提供第二个参数，则 `output` 为空字符串。

##### （3）条件执行：

```bash
if [ -n "$output" ]; then
    # 如果提供了输出文件
else
    # 如果没有提供输出文件
fi
```
- `-n "$output"` 检查 `output` 是否非空。

**执行带输出的查询：**

```bash
gccli -u"${DB_USER}" -p"${DB_PASSWD}" -vvv -e "$query" >> "$output"
```
- 如果提供了输出文件，使用 `-vvv` 选项（更详细的输出）。
- 使用 `>>` 将输出追加到指定文件。

**执行不带输出的查询：**

```bash
gccli -u"${DB_USER}" -p"${DB_PASSWD}" -Ns -e "$query"
```
- 如果没有提供输出文件，使用 `-Ns` 选项（无头输出）。

#### 3.3  `update_table_stats` 函数

用于更新表的统计信息。

```bash
compare_tables() {
    local date=$1
    execute_sql "SELECT 
        sc.v_id, sc.v_tbname, sc.v_date,
        sc.v_count_valuse AS sc_count, tg.v_count_valuse AS tg_count,
        sc.v_crc32_valuse AS sc_crc32, tg.v_crc32_valuse AS tg_crc32,
        sc.v_crc32_valuse - tg.v_crc32_valuse AS diff_crc32, sc.v_timestamp
    FROM testdb.source_table AS sc 
    LEFT JOIN testdb.target_table AS tg ON sc.v_id = tg.v_id AND sc.v_date = tg.v_date
    WHERE sc.v_date = '$date' AND sc.v_tbname = '${SC_TB_NAME}';" "${LOG_FILES[DUMP]}"
}
```

##### （1）函数参数：

```bash
local table=$1
local tbname=$2
local date=$3
local count=$4
local crc32=${5:-}
```
- 函数接受5个参数，其中 `crc32` 是可选的。
- 使用 `${5:-}` 语法为 `crc32` 提供默认值（空字符串）。

##### （2）构建查询：

```bash
local query="UPDATE testdb.${table}_table SET v_count_valuse = $count"
[ -n "$crc32" ] && query+=", v_crc32_valuse = $crc32"
query+=" WHERE v_tbname = '${tbname}' AND v_date = '$date';"
```
- 动态构建 UPDATE 查询。
- 只有在 `crc32` 非空时才添加 `v_crc32_valuse` 更新。

##### （3）执行查询：

```bash
execute_sql "$query" "${LOG_FILES[DUMP]}"
```
- 使用 `execute_sql` 函数执行查询并将结果记录到日志文件。

这个函数的优点：
- 灵活性：可以更新计数和 CRC32 值。
- 代码复用：使用 `execute_sql` 函数执行查询。
- 参数化：允许不同的表名和日期。

#### 3.4 `generate_crc32_query` 函数

是一个巧妙的实现，用于生成计算表中所有列的 CRC32 值的 SQL 查询部分。

```bash
generate_crc32_query() {
    local table=$1
    execute_sql "DESC $table;" | awk '{a = a "crc32(\""$1"\")+"} END {sub(/\+$/, "", a); print a}'
}
```

##### **（1）函数结构：**

```bash
generate_crc32_query() {
    local table=$1
    # ... 执行逻辑 ...
}
```
函数接受一个参数，即表名。

##### **（2）查询表结构：**

```bash
execute_sql "DESC $table;"
```
使用 `execute_sql` 函数执行 `DESC` 命令获取表结构。

##### **（3）使用 awk 处理结果：**

```bash
awk '{a = a "crc32(\""$1"\")+"} END {sub(/\+$/, "", a); print a}'
```
- 对每一行（每一列），生成 `crc32("列名")+` 的形式。
- 在结束时，移除最后一个多余的 `+` 符号。
- 打印最终结果。

这个函数的优点：
- 动态生成：可以适应不同的表结构。
- 简洁有效：使用 awk 进行字符串处理非常高效。
- 通用性：可以用于任何表。

#### 3.5  `compare_tables` 函数

用于比较源表和目标表的数据。

```bash
compare_tables() {
    local date=$1
    execute_sql "SELECT 
        sc.v_id, sc.v_tbname, sc.v_date,
        sc.v_count_valuse AS sc_count, tg.v_count_valuse AS tg_count,
        sc.v_crc32_valuse AS sc_crc32, tg.v_crc32_valuse AS tg_crc32,
        sc.v_crc32_valuse - tg.v_crc32_valuse AS diff_crc32, sc.v_timestamp
    FROM testdb.source_table AS sc 
    LEFT JOIN testdb.target_table AS tg ON sc.v_id = tg.v_id AND sc.v_date = tg.v_date
    WHERE sc.v_date = '$date' AND sc.v_tbname = '${SC_TB_NAME}';" "${LOG_FILES[DUMP]}"
}
```

这个 `compare_tables` 函数是一个很好的实现，用于比较源表和目标表的数据。让我详细分析这个函数，并提供一些可能的改进建议：

##### （1）函数结构：

```bash
compare_tables() {
    local date=$1
    # ... SQL 查询 ...
}
```
函数接受一个参数，即日期。

##### （2）SQL 查询：

- 查询同时从 `source_table` 和 `target_table` 获取数据。
- 使用 LEFT JOIN 确保即使在目标表中没有匹配记录也能获取源表的数据。
- 比较了计数值和 CRC32 值，并计算了 CRC32 的差异。

##### （3）执行查询：

使用 `execute_sql` 函数执行查询并将结果写入日志文件。

![image-20241017174223512](/Users/yue/Library/Application Support/typora-user-images/image-20241017174223512.png)

这个函数的优点：
- 全面比较：同时比较了记录数和 CRC32 值。
- 灵活性：可以针对特定日期进行比较。
- 使用 LEFT JOIN：确保不会遗漏源表中的数据。

#### 3.6  `select_tables` 函数

用于从源表和目标表中选择和比较数据。

```bash
select_tables() {
    local date=$1
    execute_sql "SELECT 
        sc.v_id, sc.v_tbname, sc.v_date,
        sc.v_count_valuse AS sc_count, tg.v_count_valuse AS tg_count,
        sc.v_crc32_valuse AS sc_crc32, tg.v_crc32_valuse AS tg_crc32,
        sc.v_crc32_valuse - tg.v_crc32_valuse AS diff_crc32, sc.v_timestamp
    FROM testdb.source_table AS sc 
    LEFT JOIN testdb.target_table AS tg ON sc.v_id = tg.v_id AND sc.v_date = tg.v_date
    WHERE sc.v_date like '$date' AND sc.v_tbname = '${SC_TB_NAME}';" "${LOG_FILES[DUMP]}" | tee -a "${LOG_FILES[DUMP]}" "${LOG_FILES[ALL]}"
}
```

（3）函数结构：
```bash
select_tables() {
    local date=$1
    # ... SQL 查询 ...
}
```
函数接受一个参数，即日期模式。

（3）SQL 查询：
- 使用 LEFT JOIN 来确保即使在目标表中没有匹配记录也能获取源表的数据。
- 使用 LIKE 进行日期匹配，允许更灵活的日期模式。
- 计算了 CRC32 值的差异。

（3）执行和输出：
```bash
execute_sql "..." "${LOG_FILES[DUMP]}" | tee -a "${LOG_FILES[DUMP]}" "${LOG_FILES[ALL]}"
```
- 使用 `execute_sql` 函数执行查询。
- 使用 `tee` 命令将结果同时追加到两个日志文件。

![](/Users/yue/Library/Application Support/typora-user-images/image-20241017173905862.png)



```bash
# 主处理循环
for M in "${MONTHS[@]}"; do
    DATE="${TB_YEAR}${M}"
    log "INFO" "DUMP" "####################### ${SC_TB_NAME} [$DATE] Processing begin #######################"
    
    # 统计和更新原表数据
    log "INFO" "DUMP" "Update the table count result..."
    SC_COUNT=$(execute_sql "SELECT COUNT(1) FROM ${SC_TB_NAME} WHERE ${COLUMN} BETWEEN '${TB_YEAR}-${M}-01' AND LAST_DAY('${TB_YEAR}-${M}-01');")
    update_table_stats "source" "$SC_TB_NAME" "$DATE" "$SC_COUNT"
    compare_tables $DATE

    # 插入数据到目标表
    log "INFO" "DUMP" "Inserting data into target table..."
    execute_sql "INSERT INTO ${TG_TB_NAME} SELECT * FROM ${SC_TB_NAME} WHERE ${COLUMN} BETWEEN '${TB_YEAR}-${M}-01' AND LAST_DAY('${TB_YEAR}-${M}-01') ORDER BY ${COLUMN};" "${LOG_FILES[DUMP]}"
    
    # 统计和更新目标表数据
    log "INFO" "DUMP" "Update the count result of the target table..."
    TG_COUNT=$(execute_sql "SELECT COUNT(1) FROM ${TG_TB_NAME} WHERE ${COLUMN} BETWEEN '${TB_YEAR}-${M}-01' AND LAST_DAY('${TB_YEAR}-${M}-01');")
    update_table_stats "target" "$TG_TB_NAME" "$DATE" "$TG_COUNT"
    compare_tables $DATE
    # CRC32 验证
    log "INFO" "DUMP" "Performing CRC32 verification..."
    SOURCE_CRC32_QUERY=$(generate_crc32_query "${SC_TB_NAME}")
    TARGET_CRC32_QUERY=$(generate_crc32_query "${TG_TB_NAME}")
    
    SOURCE_CRC32=$(execute_sql "SELECT SUM($SOURCE_CRC32_QUERY) FROM ${SC_TB_NAME} WHERE ${COLUMN} BETWEEN '${TB_YEAR}-${M}-01' AND LAST_DAY('${TB_YEAR}-${M}-01');")
    TARGET_CRC32=$(execute_sql "SELECT SUM($TARGET_CRC32_QUERY) FROM ${TG_TB_NAME} WHERE ${COLUMN} BETWEEN '${TB_YEAR}-${M}-01' AND LAST_DAY('${TB_YEAR}-${M}-01');")

    update_table_stats "source" "$SC_TB_NAME" "$DATE" "$SC_COUNT" "$SOURCE_CRC32"
    update_table_stats "target" "$TG_TB_NAME" "$DATE" "$TG_COUNT" "$TARGET_CRC32"

    # 比较结果
    compare_tables "$DATE"

    log "INFO" "DUMP" "####################### ${SC_TB_NAME} [$DATE] Processing end #######################"
done
```

这段代码是主处理循环，它对每个月份执行一系列操作。让我分析这段代码并提供一些可能的改进建议：

1. 循环结构：
   ```bash
   for M in "${MONTHS[@]}"; do
       DATE="${TB_YEAR}${M}"
       # ... 处理逻辑 ...
   done
   ```
   这个结构很好，它遍历了预定义的月份数组。

2. 日志记录：
   使用 `log` 函数记录处理的开始和结束，这是一个很好的做法。

3. 数据处理流程：
   - 统计和更新原表数据
   - 插入数据到目标表
   - 统计和更新目标表数据
   - 执行 CRC32 验证
   - 比较结果

这个流程逻辑清晰，涵盖了数据迁移和验证的主要步骤。



可 执 行脚 命令

hds.HX_BAFM42表

```bash
#2018
nohup /home/gbase/script/bin/03.01_Data_import_yyyy_mm_dd.sh hds.hx_bafm42 BA42TXDT 2018 &

#2019
nohup /home/gbase/script/bin/03.01_Data_import_yyyy_mm_dd.sh hds.hx_bafm42 BA42TXDT 2019 &

#2020
nohup /home/gbase/script/bin/03.01_Data_import_yyyy_mm_dd.sh hds.hx_bafm42 BA42TXDT 2020 &

#2021
nohup /home/gbase/script/bin/03.01_Data_import_yyyy_mm_dd.sh hds.hx_bafm42 BA42TXDT 2021 &

#2022
nohup /home/gbase/script/bin/03.01_Data_import_yyyy_mm_dd.sh hds.hx_bafm42 BA42TXDT 2022 &

#2023
nohup /home/gbase/script/bin/03.01_Data_import_yyyy_mm_dd.sh hds.hx_bafm42 BA42TXDT 2023 &

#2024
nohup /home/gbase/script/bin/03.01_Data_import_yyyy_mm_dd.sh hds.hx_bafm42 BA42TXDT 2024 &

#注：
1. 执行完成后，要进行日志检查，主要查看是否 crc32 校验结果是否正确；
2. 如当天切换(rename)，可执行 2024 全年，如当天不切换(rename)，建议插入的日期截止到2024年8月31日;
```

03.02_Data_import_yyyymmdd.sh

```bash
#!/bin/bash
# File_name: 03.02_Data_import_yyyymmdd.sh
# Usage:./03.02_Data_import_yyyymmdd.sh  <原库.表名> <列名> <年份> [开始月份] [结束月份] 
# 示例:./03.02_Data_import_yyyymmdd.sh hds.hx_bafm42 BA42TXDT 2018 01 06  不加月份，默认为全年
# Author: ze wen
# Date: 2024-09-28
# Description: GBase8a 8512版本,原表向目标表，插入数据，并进行crc32校对数据，日期格式为:yyyymmdd.
# Version: 1.0
set -eo pipefail

# 导入环境变量
source /home/gbase/script/bin/00.01_environment_variable.sh || { echo "Failed to source environment variables"; exit 1; }

# 参数检查
if [ $# -lt 3 ] || [ $# -gt 5 ]; then
    echo "Usage: $0 <原库.表名> <列名> <年份> [开始月份] [结束月份]"
    exit 1
fi

# 引入变量
SC_TB_NAME=$1
TG_TB_NAME="${1}_2024_bak_01"
COLUMN=$2
TB_YEAR=$3
START_MONTH=${4:-01}
END_MONTH=${5:-12}

# 生成月份数组
generate_months() {
    local start=$1
    local end=$2
    local months=()
    for ((i=start; i<=end; i++)); do
        months+=($(printf "%02d" $i))
    done
    echo "${months[@]}"
}

MONTHS=($(generate_months $START_MONTH $END_MONTH))

# 函数定义
execute_sql() {
    local query=$1
    local output=${2:-}
    if [ -n "$output" ]; then
        gccli -u"${DB_USER}" -p"${DB_PASSWD}" -vvv -e "$query" >> "$output"
    else
        gccli -u"${DB_USER}" -p"${DB_PASSWD}" -Ns -e "$query"
    fi
}

update_table_stats() {
    local table=$1
    local tbname=$2
    local date=$3
    local count=$4
    local crc32=${5:-}
    
    local query="UPDATE testdb.${table}_table SET v_count_valuse = $count"
    [ -n "$crc32" ] && query+=", v_crc32_valuse = $crc32"
    query+=" WHERE v_tbname = '${tbname}' AND v_date = '$date';"
    
    execute_sql "$query" "${LOG_FILES[DUMP]}"
}

generate_crc32_query() {
    local table=$1
    execute_sql "DESC $table;" | awk '{a = a "crc32(\""$1"\")+"} END {sub(/\+$/, "", a); print a}'
}

compare_tables() {
    local date=$1
    execute_sql "SELECT 
        sc.v_id, sc.v_tbname, sc.v_date,
        sc.v_count_valuse AS sc_count, tg.v_count_valuse AS tg_count,
        sc.v_crc32_valuse AS sc_crc32, tg.v_crc32_valuse AS tg_crc32,
        sc.v_crc32_valuse - tg.v_crc32_valuse AS diff_crc32, sc.v_timestamp
    FROM testdb.source_table AS sc 
    LEFT JOIN testdb.target_table AS tg ON sc.v_id = tg.v_id AND sc.v_date = tg.v_date
    WHERE sc.v_date = '$date' AND sc.v_tbname = '${SC_TB_NAME}';" "${LOG_FILES[DUMP]}"
}

select_tables() {
    local date=$1
    execute_sql "SELECT 
        sc.v_id, sc.v_tbname, sc.v_date,
        sc.v_count_valuse AS sc_count, tg.v_count_valuse AS tg_count,
        sc.v_crc32_valuse AS sc_crc32, tg.v_crc32_valuse AS tg_crc32,
        sc.v_crc32_valuse - tg.v_crc32_valuse AS diff_crc32, sc.v_timestamp
    FROM testdb.source_table AS sc 
    LEFT JOIN testdb.target_table AS tg ON sc.v_id = tg.v_id AND sc.v_date = tg.v_date
    WHERE sc.v_date like '$date' AND sc.v_tbname = '${SC_TB_NAME}';" "${LOG_FILES[DUMP]}" | tee -a "${LOG_FILES[DUMP]}" "${LOG_FILES[ALL]}"
}


# 主处理循环
for M in "${MONTHS[@]}"; do
    DATE="${TB_YEAR}${M}"
    log "INFO" "DUMP" "####################### ${SC_TB_NAME} [$DATE] Processing begin #######################"
    
    # 统计和更新原表数据
    log "INFO" "DUMP" "Update the table count result..."
    SC_COUNT=$(execute_sql "SELECT COUNT(1) FROM ${SC_TB_NAME} WHERE ${COLUMN} BETWEEN '${TB_YEAR}${M}01' AND LAST_DAY('${TB_YEAR}${M}01');")
    update_table_stats "source" "$SC_TB_NAME" "$DATE" "$SC_COUNT"
    compare_tables $DATE

    # 插入数据到目标表
    log "INFO" "DUMP" "Inserting data into target table..."
    execute_sql "INSERT INTO ${TG_TB_NAME} SELECT * FROM ${SC_TB_NAME} WHERE ${COLUMN} BETWEEN '${TB_YEAR}${M}01' AND LAST_DAY('${TB_YEAR}${M}01') ORDER BY ${COLUMN};" "${LOG_FILES[DUMP]}"
    
    # 统计和更新目标表数据
    log "INFO" "DUMP" "Update the count result of the target table..."
    TG_COUNT=$(execute_sql "SELECT COUNT(1) FROM ${TG_TB_NAME} WHERE ${COLUMN} BETWEEN '${TB_YEAR}${M}01' AND LAST_DAY('${TB_YEAR}${M}01');")
    update_table_stats "target" "$TG_TB_NAME" "$DATE" "$TG_COUNT"
    compare_tables $DATE
    # CRC32 验证
    log "INFO" "DUMP" "Performing CRC32 verification..."
    SOURCE_CRC32_QUERY=$(generate_crc32_query "${SC_TB_NAME}")
    TARGET_CRC32_QUERY=$(generate_crc32_query "${TG_TB_NAME}")
    
    SOURCE_CRC32=$(execute_sql "SELECT SUM($SOURCE_CRC32_QUERY) FROM ${SC_TB_NAME} WHERE ${COLUMN} BETWEEN '${TB_YEAR}${M}01' AND LAST_DAY('${TB_YEAR}${M}01');")
    TARGET_CRC32=$(execute_sql "SELECT SUM($TARGET_CRC32_QUERY) FROM ${TG_TB_NAME} WHERE ${COLUMN} BETWEEN '${TB_YEAR}${M}01' AND LAST_DAY('${TB_YEAR}${M}01');")

    update_table_stats "source" "$SC_TB_NAME" "$DATE" "$SC_COUNT" "$SOURCE_CRC32"
    update_table_stats "target" "$TG_TB_NAME" "$DATE" "$TG_COUNT" "$TARGET_CRC32"

    # 比较结果
    compare_tables "$DATE"

    log "INFO" "DUMP" "####################### ${SC_TB_NAME} [$DATE] Processing end #######################"
done

# 年度总结
log "INFO" "DUMP" "Summary for ${TB_YEAR} from month $START_MONTH to $END_MONTH:"
select_tables "${TB_YEAR}%"

log "INFO" "DUMP" "Processing completed. Log file: ${LOG_FILES[DUMP]}"
```

